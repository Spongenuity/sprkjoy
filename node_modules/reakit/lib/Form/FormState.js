'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var useId = require('reakit-utils/useId');
var __chunk_1 = require('../chunk-002fc018.js');
var useSealedState = require('reakit-utils/useSealedState');
var useUpdateEffect = require('reakit-utils/useUpdateEffect');
var isPromise = require('reakit-utils/isPromise');
var isEmpty = require('reakit-utils/isEmpty');
var isObject = require('reakit-utils/isObject');
var setAllIn = require('./utils/setAllIn.js');
var getIn = require('./utils/getIn.js');
require('reakit-utils/toArray');
require('reakit-utils/isInteger');
var setIn = require('./utils/setIn.js');

function filterAllEmpty(object) {
  if (Array.isArray(object)) {
    return object.filter(function (value) {
      if (isObject.isObject(value)) {
        return filterAllEmpty(value);
      }

      return true;
    });
  }

  var result = {};
  var keys = Object.keys(object);

  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
    var key = _keys[_i];
    var k = key;
    var value = object[k];
    result[k] = isObject.isObject(value) ? filterAllEmpty(value) : object[k];
  }

  return result;
}

function hasMessages(errors) {
  return isObject.isObject(errors) && !isEmpty.isEmpty(errors);
}

function getMessages(stateMessages, actionMessages) {
  return !isEmpty.isEmpty(actionMessages) ? actionMessages : isEmpty.isEmpty(stateMessages) ? stateMessages : {};
}

function reducer(state, action) {
  switch (action.type) {
    case "reset":
      {
        return __chunk_1._objectSpread({}, state, {
          values: state.initialValues,
          touched: {},
          errors: {},
          messages: {},
          valid: true,
          validating: false,
          submitting: false,
          submitFailed: 0,
          submitSucceed: 0
        });
      }

    case "startValidate":
      {
        return __chunk_1._objectSpread({}, state, {
          validating: true
        });
      }

    case "endValidate":
      {
        return __chunk_1._objectSpread({}, state, {
          validating: false,
          errors: getMessages(state.errors, action.errors),
          messages: getMessages(state.messages, action.messages),
          valid: !hasMessages(action.errors)
        });
      }

    case "startSubmit":
      {
        return __chunk_1._objectSpread({}, state, {
          // @ts-ignore TS bug
          touched: setAllIn.unstable_setAllIn(state.values, true),
          submitting: true
        });
      }

    case "endSubmit":
      {
        var valid = !hasMessages(action.errors);
        return __chunk_1._objectSpread({}, state, {
          valid: valid,
          submitting: false,
          errors: getMessages(state.errors, action.errors),
          messages: getMessages(state.messages, action.messages),
          submitSucceed: valid ? state.submitSucceed + 1 : state.submitSucceed,
          submitFailed: valid ? state.submitFailed : state.submitFailed + 1
        });
      }

    case "update":
      {
        var _name = action.name,
            _value = action.value;
        var nextValue = typeof _value === "function" ? _value(getIn.unstable_getIn(state.values, _name)) : _value;
        return __chunk_1._objectSpread({}, state, {
          values: setIn.unstable_setIn(state.values, _name, nextValue != null ? nextValue : "")
        });
      }

    case "blur":
      {
        return __chunk_1._objectSpread({}, state, {
          touched: setIn.unstable_setIn(state.touched, action.name, true)
        });
      }

    case "push":
      {
        var array = getIn.unstable_getIn(state.values, action.name, []);
        return __chunk_1._objectSpread({}, state, {
          values: setIn.unstable_setIn(state.values, action.name, [].concat(array, [action.value]))
        });
      }

    case "remove":
      {
        var _array = getIn.unstable_getIn(state.values, action.name, []);

        delete _array[action.index];
        return __chunk_1._objectSpread({}, state, {
          values: setIn.unstable_setIn(state.values, action.name, _array)
        });
      }

    default:
      {
        throw new Error();
      }
  }
}

function unstable_useFormState(initialState) {
  if (initialState === void 0) {
    initialState = {};
  }

  var _useSealedState = useSealedState.useSealedState(initialState),
      _useSealedState$baseI = _useSealedState.baseId,
      baseId = _useSealedState$baseI === void 0 ? useId.useId("form-") : _useSealedState$baseI,
      _useSealedState$value = _useSealedState.values,
      initialValues = _useSealedState$value === void 0 ? {} : _useSealedState$value,
      _useSealedState$valid = _useSealedState.validateOnBlur,
      validateOnBlur = _useSealedState$valid === void 0 ? true : _useSealedState$valid,
      _useSealedState$valid2 = _useSealedState.validateOnChange,
      validateOnChange = _useSealedState$valid2 === void 0 ? true : _useSealedState$valid2,
      _useSealedState$reset = _useSealedState.resetOnSubmitSucceed,
      resetOnSubmitSucceed = _useSealedState$reset === void 0 ? false : _useSealedState$reset,
      _useSealedState$reset2 = _useSealedState.resetOnUnmount,
      resetOnUnmount = _useSealedState$reset2 === void 0 ? true : _useSealedState$reset2,
      onValidate = _useSealedState.onValidate,
      onSubmit = _useSealedState.onSubmit;

  var _React$useReducer = React.useReducer(reducer, {
    baseId: baseId,
    initialValues: initialValues,
    values: initialValues,
    touched: {},
    errors: {},
    messages: {},
    valid: true,
    validating: false,
    submitting: false,
    submitFailed: 0,
    submitSucceed: 0
  }),
      _React$useReducer$ = _React$useReducer[0],
      _ = _React$useReducer$.initialValues,
      state = __chunk_1._objectWithoutPropertiesLoose(_React$useReducer$, ["initialValues"]),
      dispatch = _React$useReducer[1];

  var validate = React.useCallback(function (vals) {
    if (vals === void 0) {
      vals = state.values;
    }

    return new Promise(function (resolve) {
      if (onValidate) {
        var response = onValidate(filterAllEmpty(vals));

        if (isPromise.isPromise(response)) {
          dispatch({
            type: "startValidate"
          });
        }

        resolve(Promise.resolve(response).then(function (messages) {
          dispatch({
            type: "endValidate",
            messages: messages
          });
          return messages;
        }));
      } else {
        resolve(undefined);
      }
    })["catch"](function (errors) {
      dispatch({
        type: "endValidate",
        errors: errors
      });
      throw errors;
    });
  }, [state.values, onValidate]);
  useUpdateEffect.useUpdateEffect(function () {
    if (validateOnChange) {
      validate()["catch"](function () {});
    }
  }, [validate, validateOnChange]);
  React.useEffect(function () {
    if (resetOnUnmount) {
      return function () {
        dispatch({
          type: "reset"
        });
      };
    }

    return undefined;
  }, [resetOnUnmount]);
  return __chunk_1._objectSpread({}, state, {
    values: state.values,
    validate: validate,
    reset: React.useCallback(function () {
      return dispatch({
        type: "reset"
      });
    }, []),
    submit: React.useCallback(function () {
      dispatch({
        type: "startSubmit"
      });
      return validate().then(function (validateMessages) {
        if (onSubmit) {
          return Promise.resolve(onSubmit(state.values)).then(function (submitMessages) {
            var messages = __chunk_1._objectSpread({}, validateMessages, submitMessages);

            dispatch({
              type: "endSubmit",
              messages: messages
            });

            if (resetOnSubmitSucceed) {
              dispatch({
                type: "reset"
              });
            }
          });
        }

        dispatch({
          type: "endSubmit",
          messages: validateMessages
        });
        return undefined;
      })["catch"](function (errors) {
        dispatch({
          type: "endSubmit",
          errors: errors
        });
      });
    }, [validate]),
    update: React.useCallback(function (name, value) {
      return dispatch({
        type: "update",
        name: name,
        value: value
      });
    }, []),
    blur: React.useCallback(function (name) {
      dispatch({
        type: "blur",
        name: name
      });

      if (validateOnBlur) {
        validate()["catch"](function () {});
      }
    }, [validate]),
    push: React.useCallback(function (name, value) {
      return dispatch({
        type: "push",
        name: name,
        value: value
      });
    }, []),
    remove: React.useCallback(function (name, index) {
      return dispatch({
        type: "remove",
        name: name,
        index: index
      });
    }, [])
  });
}
var keys = ["baseId", "values", "touched", "messages", "errors", "validating", "valid", "submitting", "submitSucceed", "submitFailed", "validate", "submit", "reset", "update", "blur", "push", "remove"];
unstable_useFormState.__keys = keys;

exports.unstable_useFormState = unstable_useFormState;
